<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="sql.TFileSystem">
    <insert id="makeEntry">
        insert into ${tableName} (name, parent_id, type, ref_id, options, id)
        values (#{name}, #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}, #{type}, #{refId}, #{options},
                #{id,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler})
    </insert>
    <update id="createRootTable">
        create table ${tableName}
        (
            id        bigserial not null primary key,
            parent_id bigint    not null,
            name      text,
            type      text      not null,
            ref_id    text,
            options   int default 0
        )
    </update>

    <update id="createIndex">
        create index ${indexName} on ${tableName} (${fields})
    </update>
    <update id="update2uuids">
        update ${tableName}
        set uuid = #{uuid,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
        where id = #{oldId}
    </update>
    <delete id="dropEntry">
        delete
        from ${viewName} f
        where f.name = #{name}
          and f.parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
          and f.owner = #{owner}
    </delete>
    <delete id="dropEntries">
        delete from ${tableName}
        where id in
        <foreach collection="ids" item="id" open="(" close=")" separator=",">#{id,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}</foreach>
    </delete>

    <select id="isIndexMissed" resultType="_boolean">
        select not exists(select 1
                          from pg_class t,
                               pg_class i,
                               pg_index ix,
                               pg_attribute a
                          where t.oid = ix.indrelid
                            and i.oid = ix.indexrelid
                            and a.attrelid = t.oid
                            and a.attnum = ANY (ix.indkey)
                            and t.relkind = 'r'
                            and i.relname = #{indexName}

                          order by t.relname,
                                   i.relname)
    </select>
    <select id="isTableMissed" resultType="_boolean">
        SELECT not EXISTS(SELECT 1
                          FROM information_schema.tables
                          WHERE table_schema = 'public'
                            AND table_name = #{tableName}
            )
    </select>
    <select id="isViewMissed" resultType="_boolean">
        SELECT not EXISTS(SELECT 1
                          FROM information_schema.views
                          WHERE table_schema = 'public'
                            AND table_name = #{viewName}
            )
    </select>
    <select id="listChilds" resultMap="EntryMap">
        select f.*, fp.path
        from ${viewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where f.parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
    </select>

    <select id="getRawTable" resultType="java.util.Map">
        select *
        from ${tableName}
    </select>
    <select id="isEntryExist" resultType="_boolean">
        select exists(select 1 from ${viewName} where name = #{name} and parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler})
    </select>
    <select id="getEntry" resultMap="EntryMap">
        select f.*, fp.path
        from ${viewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where f.id = #{id,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
    </select>
    <select id="listTypedChilds" resultMap="EntryMap">
        select f.*, fp.path
        from ${viewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where f.type = #{type}
    </select>
    <select id="getPredictors" resultType="model.TFile">
        with recursive a as (
            select head.id, head.parent_id
            from ${viewName} head
            where head.id = #{id,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
            union all
            select tail.id, tail.parent_id
            from ${viewName} tail
                     join a on tail.id = a.parent_id)
        select a.id, a.parent_id as "parentId"
        from a
    </select>
    <select id="search" resultMap="EntryMap">
        select f.*, fp.path
        from ${viewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where lower(f.name) like #{query}
          and f.id in (
            WITH RECURSIVE tree AS
                               (
                                   SELECT id,
                                          parent_id
                                   FROM ${treeViewName}
                                   WHERE id = #{fromDirId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
                                      or parent_id = #{fromDirId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
                                   UNION ALL
                                   SELECT si.id,
                                          si.parent_id
                                   FROM ${treeViewName} As si
                                            JOIN
                                        tree AS sp
                                        ON (si.parent_id = sp.id)
                               )
            SELECT id
            FROM tree)
    </select>
    <update id="addUuidParent">
        alter table ${tableName}
            add if not exists parent_uuid uuid
    </update>
    <update id="addUuid">
        alter table ${tableName}
            add if not exists uuid uuid
    </update>
    <update id="createShareView">
        create or replace view ${viewName} (id, name, type, parent_id, ref_id, options, owner, rw) as
        (
        WITH RECURSIVE tree AS
                           (
                               SELECT id,
                                      name,
                                      type,
                                      cast(#{shareDirId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler} as uuid) as parent_id,
                                      options,
                                      ref_id
                               FROM ${shareOwnerTableName}
                               WHERE id = #{shareEntryId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
                               UNION ALL
                               SELECT si.id,
                                      si.name,
                                      si.type,
                                      si.parent_id,
                                      si.options,
                                      si.ref_id
                               FROM ${shareOwnerTableName} As si
                                        JOIN
                                    tree AS sp
                                    ON (si.parent_id = sp.id)
                           )
        SELECT tree.id,
               tree.name,
               tree.type,
               tree.parent_id,
               tree.ref_id,
               tree.options,
               share.owner,
               share.rw
        FROM tree
                 left join shares share on share.id = #{shareId})
    </update>

    <update id="createFsView">
        create or replace view ${viewName} as (
        select id, parent_id, name, type, ref_id, options, cast(${ownerId} as bigint) as "owner", true as "rw" from ${rootTableName}
        <foreach collection="shares" item="shareView">
            union all
            select id, parent_id, name, type, ref_id, options, owner, rw from ${shareView}
        </foreach>
        )
    </update>

    <update id="createFsTree">
        create or replace view ${viewName} (id, parent_id, owner, path) as
        (
        WITH RECURSIVE tree AS
                           (
                               SELECT id,
                                      name,
                                      parent_id,
                                      owner,
                                      ARRAY [name] AS fpath
                               FROM ${consolidatedViewName}
                               WHERE parent_id is null
                               UNION ALL
                               SELECT si.id,
                                      si.name,
                                      si.parent_id,
                                      si.owner,
                                      sp.fpath || si.name As fpath
                               FROM ${consolidatedViewName} As si
                                        JOIN
                                    tree AS sp
                                    ON (si.parent_id = sp.id and si.owner = sp.owner)
                           )
        SELECT id, parent_id, owner, array_to_string(fpath, '/')
        FROM tree)
    </update>

    <update id="dropView">
        drop view if exists ${viewName}
    </update>
    <select id="selectShareViewsLike" resultType="java.lang.String">
        SELECT table_name
        FROM information_schema.views
        WHERE table_schema = 'public'
          AND table_name like #{query}
    </select>

    <select id="selectRootDirs" resultType="model.TFile">
        select id, name, options
        from ${tableName}
        where type = 'DIR'
          and parent_id in (select id from ${tableName} where parent_id is null)
    </select>
    <select id="selectSubDirs" resultType="model.TFile">
        select id, name, options, parent_id, ref_id as "refId"
        from ${tableName}
        where parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
          and type = 'DIR'
    </select>
    <select id="isNameBusy" resultType="_boolean">
        select exists(select 1 from ${tableName} where name = #{name} and parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler})
    </select>

    <select id="findEntry" resultMap="EntryMap">
        select f.*, fp.path
        from ${viewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where f.name = #{name}
          and f.parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
          and f.owner = #{owner}
        limit 1
    </select>

    <select id="findRoot" resultMap="EntryMap">
        select f.*, fp.path
        from ${fsViewName} f
                 left join ${treeViewName} fp on (f.id = fp.id)
        where f.parent_id is null and f.type = 'DIR'
        limit 1
    </select>

    <update id="updateEntry">
        update ${tableName}
        set name      = #{name},
            parent_id = #{parentId,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler},
            options   = #{options}
        where id = #{id,javaType=UUID,jdbcType=OTHER,typeHandler=UUIDTypeHandler}
    </update>

    <resultMap id="EntryMap" type="model.TFile">
        <id column="id" property="id" typeHandler="utils.UUIDTypeHandler"/>
        <result column="parent_id" property="parentId" typeHandler="utils.UUIDTypeHandler"/>
        <result column="name" property="name"/>
        <result column="type" property="type"/>
        <result column="ref_id" property="refId"/>
        <result column="options" property="options"/>
        <result column="path" property="path"/>
        <result property="owner" column="owner"/>
        <result property="rw" column="rw"/>
    </resultMap>

    <!-- old timers -->

    <update id="old0">
        update fs_struct_${uid}
        set parent_uuid = subquery.uuid

        from (select id, uuid, parent_id from fs_struct_${uid}) as subquery
        where fs_struct_${uid}.parent_id = subquery.id;
    </update>
    <update id="old1">
        alter table fs_struct_${uid}
            drop column parent_id;
    </update>
    <update id="old2">
        alter table fs_struct_${uid}
            alter column uuid set not null;
    </update>
    <update id="old3">
        alter table fs_struct_${uid}
            alter column parent_uuid set not null;
    </update>
    <update id="old4">
        alter table fs_struct_${uid}
            add if not exists options int default 0
    </update>
    <update id="old5">
        alter table fs_struct_${uid}
            drop constraint fs_struct_${uid}_pkey;
    </update>
    <update id="old6">
        alter table fs_struct_${uid}
            drop column id;
    </update>
    <update id="old65">
        alter table fs_struct_${uid}
            rename column uuid to id;
    </update>
    <update id="old7">
        alter table fs_struct_${uid}
            add constraint fs_struct_${uid}_pkey primary key (id);
    </update>
    <update id="old8">
        alter table fs_struct_${uid}
            rename column parent_uuid to parent_id;
    </update>
    <update id="old10">
        alter table fs_struct_${uid} alter column ref_id drop not null
    </update>
    <update id="old11">
        alter table fs_struct_${uid} alter column ref_id drop default
    </update>
    <update id="old12">
        alter table fs_struct_${uid} drop column if exists selected
    </update>
    <update id="old13">
        alter table fs_struct_${uid} drop column if exists found
    </update>
    <update id="old14">
        alter table fs_struct_${uid} drop column if exists uuid
    </update>
    <update id="old15">
        alter table fs_struct_${uid} drop column if exists size
    </update>

</mapper>
